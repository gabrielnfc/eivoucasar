# Wedding MicroSaaS - Regras para desenvolvimento limpo e eficiente

## ğŸ¯ PRINCÃPIOS FUNDAMENTAIS

- KISS (Keep It Simple, Stupid) - Simplicidade acima de tudo
- DRY (Don't Repeat Yourself) - Zero duplicaÃ§Ã£o desnecessÃ¡ria
- YAGNI (You Aren't Gonna Need It) - Evite over-engineering
- Clean Code - CÃ³digo legÃ­vel e auto-documentado
- Performance First - OtimizaÃ§Ãµes desde o inÃ­cio

## ğŸ“ CONVENÃ‡Ã•ES DE NOMENCLATURA

### Componentes: PascalCase

WeddingCard, GuestList, ContributionForm

### Arquivos: kebab-case

wedding-card.tsx, guest-list.tsx, contribution-form.tsx

### VariÃ¡veis/FunÃ§Ãµes: camelCase

guestCount, handleSubmit, createPayment

### Constantes: UPPER_SNAKE_CASE

MAX_GUESTS, DEFAULT_THEME, API_ENDPOINTS

### Tipos/Interfaces: PascalCase com sufixo

type User = {...}
interface GuestData {...}
type PaymentStatus = "pending" | "paid"

## ğŸ—ï¸ ESTRUTURA DE COMPONENTES

### SEMPRE use esta estrutura

1. Imports (externos â†’ internos â†’ tipos)
2. Tipos/Interfaces locais
3. Component principal
4. Export default

### Exemplo

import { useState } from 'react'
import { Button } from '@/components/ui/button'
import type { Guest } from '@/types'

interface Props {
  guests: Guest[]
}

export default function GuestList({ guests }: Props) {
  // lÃ³gica aqui
}

## ğŸ¨ ESTILIZAÃ‡ÃƒO MODERNA

### Use apenas Tailwind utility classes

- NUNCA custom CSS a menos que absolutamente necessÃ¡rio
- Prefira classes semÃ¢nticas: bg-white, text-gray-900
- Use design tokens consistentes: space-4, text-sm, rounded-lg
- Dark mode ready: dark:bg-gray-900, dark:text-white

### Paleta moderna minimalista

- Primary: slate-900, slate-50
- Accent: rose-500, rose-50
- Success: emerald-500, emerald-50
- Warning: amber-500, amber-50
- Error: red-500, red-50

### Componentes minimalistas

- Bordas sutis: border border-gray-200
- Sombras leves: shadow-sm, shadow-md (mÃ¡ximo)
- EspaÃ§amentos consistentes: p-4, gap-4, space-y-4
- Tipografia limpa: text-sm, font-medium, leading-relaxed

## âš›ï¸ PADRÃ•ES REACT/NEXT.JS

### Server Components por padrÃ£o

- Use 'use client' APENAS quando necessÃ¡rio (interatividade)
- Prefira Server Components para busca de dados
- Client Components apenas para: forms, states, eventos

### Hooks personalizados para lÃ³gica complexa

- Exemplo

function useGuests(coupleId: string) {
  const [guests, setGuests] = useState<Guest[]>([])
  // lÃ³gica aqui
  return { guests, addGuest, updateGuest }
}

### NUNCA duplicate cÃ³digo

- Extraia lÃ³gica comum em hooks
- Crie componentes reutilizÃ¡veis
- Use constantes para valores repetidos

## ğŸ—ƒï¸ PADRÃ•ES DE DATABASE

### SEMPRE use Prisma com TypeScript

- Tipos automÃ¡ticos: Prisma.Guest, Prisma.Couple
- Queries type-safe: prisma.guest.findMany()
- NUNCA SQL raw desnecessÃ¡rio

### RLS (Row Level Security) obrigatÃ³rio

auth.uid() = couples.user_id

### PadrÃ£o de queries

const guests = await prisma.guest.findMany({
  where: { coupleId },
  include: { group: true },
  orderBy: { createdAt: 'desc' }
})

## ğŸ”§ PADRÃ•ES DE API

### SEMPRE validaÃ§Ã£o com Zod

import { z } from 'zod'

const guestSchema = z.object({
  name: z.string().min(1),
  email: z.string().email(),
  phone: z.string().optional()
})

### Error handling consistente

try {
  const result = await action()
  return { success: true, data: result }
} catch (error) {
  return { success: false, error: error.message }
}

### NUNCA exponha dados sensÃ­veis

- Sempre select especÃ­fico
- Sanitize outputs
- Rate limiting em APIs pÃºblicas

## ğŸ“± RESPONSIVIDADE MODERNA

### Mobile-first sempre

- Base: mobile design
- md: tablet (768px+)
- lg: desktop (1024px+)
- xl: large desktop (1280px+)

### Grid moderno

grid-cols-1 md:grid-cols-2 lg:grid-cols-3

### Flexbox semÃ¢ntico

flex flex-col md:flex-row items-center justify-between

## ğŸš€ PERFORMANCE

### OtimizaÃ§Ãµes obrigatÃ³rias

- Dynamic imports: const Component = dynamic(() => import('./Heavy'))
- Image optimization: Image do Next.js sempre
- Lazy loading: loading="lazy" por padrÃ£o
- Bundle analysis: evite bibliotecas pesadas

### Evite re-renders

- React.memo para componentes pesados
- useMemo para computaÃ§Ãµes custosas
- useCallback para funÃ§Ãµes em deps

## ğŸ” SEGURANÃ‡A

### ValidaÃ§Ã£o em mÃºltiplas camadas

1. Frontend (UX) - Zod schemas
2. API (seguranÃ§a) - ValidaÃ§Ã£o server-side
3. Database (integridade) - Constraints

### NUNCA confie no cliente

- Sempre validar no servidor
- Rate limiting em APIs
- Sanitize inputs

## ğŸ§ª QUALIDADE DE CÃ“DIGO

### ComentÃ¡rios apenas quando necessÃ¡rio

- CÃ³digo deve ser auto-explicativo
- ComentÃ¡rios para lÃ³gica complexa de negÃ³cio
- JSDoc para funÃ§Ãµes utilitÃ¡rias

### RefatoraÃ§Ã£o contÃ­nua

- FunÃ§Ãµes pequenas (< 20 linhas)
- Componentes focados (single responsibility)
- Extraia constantes e tipos

### EVITE

- Nested ternÃ¡rios complexos
- FunÃ§Ãµes anÃ´nimas em JSX
- Estados desnecessÃ¡rios
- Props drilling (use context quando necessÃ¡rio)

## ğŸ”„ PADRÃ•ES DE ESTADO

### useState para estado local simples

### Para estado complexo, use useReducer

const [state, dispatch] = useReducer(reducer, initialState)

### Context apenas para

- Tema/configuraÃ§Ãµes globais
- Auth state
- Multi-tenant context (couple data)

### NUNCA global state desnecessÃ¡rio

## ğŸ“¦ IMPORTS ORGANIZADOS

### Ordem

1. React/Next.js
2. Bibliotecas externas
3. Componentes internos
4. Utils/helpers
5. Tipos

- Exemplo

import React from 'react'
import { NextPage } from 'next'
import { Button } from '@/components/ui/button'
import { GuestCard } from '@/components/guest-card'
import { formatDate } from '@/lib/utils'
import type { Guest } from '@/types'

## ğŸŒ MULTI-TENANCY

### SEMPRE considere isolamento

- RLS no banco
- Middleware para routing
- Context para tenant atual
- Cache por tenant

### PadrÃ£o de hook

function useTenant() {
  const { slug } = useParams()
  const couple = useCoupleBySlug(slug)
  return { couple, isLoading }
}

## ğŸ¯ INTEGRAÃ‡Ã•ES

### Wrapper pattern para APIs externas

class AbacatePayService {
  async createPayment(data: PaymentData) {
    // implementaÃ§Ã£o limpa
  }
}

### NUNCA hardcode credentials

- Use env vars sempre
- Validate env vars na inicializaÃ§Ã£o
- Type-safe env com Zod

## ğŸš¨ ANTI-PATTERNS (NUNCA FAÃ‡A)

âŒ Componentes gigantes (>200 linhas)
âŒ Props drilling profundo
âŒ useState para dados do servidor
âŒ Fetch direto em componentes
âŒ CSS inline ou styled-components
âŒ console.log em produÃ§Ã£o
âŒ any types no TypeScript
âŒ MutaÃ§Ã£o direta de state
âŒ useEffect para tudo
âŒ Nested folders profundos

## âœ… BOAS PRÃTICAS (SEMPRE FAÃ‡A)

âœ… Componentes pequenos e focados
âœ… Custom hooks para lÃ³gica
âœ… Server Components quando possÃ­vel
âœ… Error boundaries em componentes crÃ­ticos
âœ… Loading states consistentes
âœ… TypeScript strict mode
âœ… Accessible components (a11y)
âœ… SEO meta tags
âœ… Progressive enhancement
âœ… Graceful degradation

## ğŸ” CODE REVIEW CHECKLIST

Antes de commitar, verifique:
â–¡ Zero TypeScript errors
â–¡ Zero console.logs
â–¡ Componentes < 200 linhas
â–¡ Nomes descritivos
â–¡ Sem duplicaÃ§Ã£o
â–¡ Performance otimizada
â–¡ Acessibilidade bÃ¡sica
â–¡ Mobile responsive
â–¡ Error handling
â–¡ Loading states
